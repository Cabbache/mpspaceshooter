<!DOCTYPE HTML>
<html>
<head>
	<title>cche</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			overflow: hidden;
			background-color: #000000;
		}
	</style>
	
	<script src="static/pixi.js"></script>
</head>
<body>
<script>
	var gameState = [];
	var socket = null;
	var opened = false;
	var keymap = {
		"ArrowUp": false,
		"ArrowDown": false,
		"ArrowLeft": false,
		"ArrowRight": false,
		"A": false,
		"D": false
	};
	const app = new PIXI.Application({
			width: window.innerWidth,
			height: window.innerHeight,
			backgroundColor: 0x101010
	});

	const invr2 = 0.7071067811865475;

	const openWebSocket = function(){
		fetch(`http://${window.location.hostname}/register`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			body: "{}"
		})
		.then(response => response.json())
		.then(result => {
			socket = new WebSocket(`ws://${window.location.hostname}/ws/`+result['private']);
			socket.onmessage = recvFn;
			socket.onopen = () => {
				opened=true;
				socket.send(JSON.stringify({"t":"StateQuery"}));
			};
			socket.onclose = (event)=>{
				opened=false;
				console.log(event.wasClean ? "closed cleanly":"connection died");
			}
		});
	};

	const handle_gamestate = function(state){
		for (var i = app.stage.children.length - 1; i >= 0; i--) {	app.stage.removeChild(app.stage.children[i]);};
		gameState = state.map((p) => {
			const square = new PIXI.Sprite(PIXI.Texture.WHITE);
			square.anchor.set(0.5);
			square.width = 50;
			square.height = 50;
			square.tint = 0xff9900;
			square.position.set(p.x, p.y);
			square.rotation = p.rotation;
			app.stage.addChild(square);
			return {
				graphics: square,
				p: p
			};
		});	
	};

	const handle_motionupdate = function(content){
		let broadcaster = content["from"];
		for (let i = 0;i < gameState.length;++i){
			if (gameState[i].p.public_id == broadcaster){
				console.log("updated motion to " + content.direction);
				gameState[i].p.motion.direction = content.direction;
				gameState[i].graphics.x = content.x;
				gameState[i].graphics.y = content.y;
				break;
			}
		}
	}

	const handle_rotationupdate = function(content){
		let broadcaster = content["from"];
		for (let i = 0;i < gameState.length;++i){
			if (gameState[i].p.public_id == broadcaster){
				console.log("updated rotation to " + content.direction);
				gameState[i].p.rotation_motion.direction = content.direction;
				gameState[i].graphics.rotation = content.r;
				break;
			}
		}
	}

	const handle_playerjoin = function(content){
		const square = new PIXI.Sprite(PIXI.Texture.WHITE);
		square.anchor.set(0.5);
		square.width = 50;
		square.height = 50;
		square.tint = 0xff9900;
		square.position.set(content.x, content.y);
		app.stage.addChild(square);
		gameState.push({
			graphics: square,
			p: content
		});
	}

	const handle_playerleave = function(content){
		let toremove = -1;
		for (let i = 0;i < gameState.length;++i){
			if (gameState[i].p.public_id != content)
				continue;
			app.stage.removeChild(gameState[i].graphics);
			toremove = i;
		}
		if (toremove == -1){
			console.error("Cant find player to remove on leave");
		}
		gameState.splice(toremove, 1);
	}

	const recvFn = function(event) {
		console.log("receive: " + event.data);
		let data = JSON.parse(event.data);
		let datatype = data["t"];
		let content = data["c"];
		switch (datatype){
			case "GameState": handle_gamestate(content); break;
			case "MotionUpdate": handle_motionupdate(content); break;
			case "RotationUpdate": handle_rotationupdate(content); break;
			case "PlayerJoin": handle_playerjoin(content); break;
			case "PlayerLeave": handle_playerleave(content); break;
			default: console.error("received uknown server message");break;
		}
		console.log("gamestate: " + gameState.map((f) => JSON.stringify(f.p)));
	};

	const keyAction = function (repeated, name, up){
		console.log(name);
		if (!opened || repeated) return;

		let translation_keys = ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"];
		let rotation_keys = ["a","d"]; //case sensitive (todo make this insensitive)

		keymap[name] = !up;

		if (translation_keys.includes(name)){
			let response = "";
			if (keymap["ArrowUp"] && keymap["ArrowRight"]){
				response = "MoveUpRight";
			} else if (keymap["ArrowUp"] && keymap["ArrowLeft"]){
				response = "MoveUpLeft";
			} else if (keymap["ArrowUp"]){
				response = "MoveUp";
			}else if (keymap["ArrowDown"] && keymap["ArrowRight"]){
				response = "MoveDownRight";
			} else if (keymap["ArrowDown"] && keymap["ArrowLeft"]){
				response = "MoveDownLeft";
			} else if (keymap["ArrowDown"]){
				response = "MoveDown";
			} else if (keymap["ArrowLeft"]){
				response = "MoveLeft";
			} else if (keymap["ArrowRight"]){
				response = "MoveRight";
			} else {
				response = "Stopped";
			}
			console.log("sending " + response);
			socket.send(
				JSON.stringify({
					"t":"MotionUpdate",
					"c":{
						"motion": response,
					 }
				})
			);
		} else if (rotation_keys.includes(name)) {
			let response = "";
			if (keymap["a"]){
				response = "AntiClockwise";
			} else if (keymap["d"]){
				response = "Clockwise";
			} else {
				response = "Stopped";
			}
			console.log("sending " + response);
			socket.send(
				JSON.stringify({
					"t":"RotationUpdate",
					"c":{
						"direction": response,
					 }
				})
			);
		}
	};


	document.body.appendChild(app.view);

	openWebSocket();

	// Define the speed and direction of the square's movement
	let speed = 200;
	let rotation_speed = 3.14159265358979323;

	const ticker = PIXI.Ticker.shared.add(delta => {
		const deltaTime = delta / (1000*PIXI.settings.TARGET_FPMS);
		for (let player of gameState){
			
			//apply rotations
			switch (player.p.rotation_motion.direction){
				case "Clockwise":
					player.graphics.rotation += rotation_speed * deltaTime;break;
				case "AntiClockwise":
					player.graphics.rotation += -rotation_speed * deltaTime;break;
			}
			
			//apply translations
			switch (player.p.motion.direction){
				case "MoveUp":
					player.graphics.y -= speed * deltaTime;break;
				case "MoveDown":
					player.graphics.y += speed * deltaTime;break;
				case "MoveLeft":
					player.graphics.x -= speed * deltaTime;break;
				case "MoveRight":
					player.graphics.x += speed * deltaTime;break;
				case "MoveUpRight":
					player.graphics.x += speed * deltaTime * invr2;
					player.graphics.y -= speed * deltaTime * invr2;
					break;
				case "MoveDownRight":
					player.graphics.x += speed * deltaTime * invr2;
					player.graphics.y += speed * deltaTime * invr2;
					break;
				case "MoveDownLeft":
					player.graphics.x -= speed * deltaTime * invr2;
					player.graphics.y += speed * deltaTime * invr2;
					break;
				case "MoveUpLeft":
					player.graphics.x -= speed * deltaTime * invr2;
					player.graphics.y -= speed * deltaTime * invr2;
					break;
			}

		}
	});

	ticker.speed = 1;
	ticker.minFPS = 30;
	ticker.maxFPS = 60;
	ticker.start();

	window.addEventListener("resize", function(){
    app.renderer.resize(window.innerWidth, window.innerHeight);
	});

	window.addEventListener('keydown', (event) => keyAction(event.repeat, event.key, false));
	window.addEventListener('keyup', (event) => keyAction(event.repeat, event.key, true));

</script>
</body>
</html>
