<!DOCTYPE HTML>
<html>
<head>
	<title>cche</title>
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<link rel="stylesheet" href="static/styles.css">
	<script src="static/pixi.js"></script> <!-- PIXI -->
	<script src="static/pe.min.js"></script> <!-- Emitters -->
</head>
<body>
  <div class="modal" id="join-modal">
    <div class="modal-dialog">
      <div class="modal-header">
        <h2>Hello!</h2>
      </div>
      <div class="modal-body">
        <form>
          <input type="text" name="nick" placeholder="What is your name? (3 to 24 characters)" autocomplete="off">

          <div class="color-selector">
						<input type="radio" id="color-red" name="color" value="red">
						<label for="color-red" style="background-color: rgb(200, 0, 0);"></label>

						<input type="radio" id="color-orange" name="color" value="orange">
						<label for="color-orange" style="background-color: rgb(255, 150, 0);"></label>

						<input type="radio" id="color-yellow" name="color" value="yellow">
						<label for="color-yellow" style="background-color: rgb(255, 255, 0);"></label>

						<input type="radio" id="color-green" name="color" value="green">
						<label for="color-green" style="background-color: rgb(0, 150, 0);"></label>

						<input type="radio" id="color-blue" name="color" value="blue">
						<label for="color-blue" style="background-color: rgb(0, 0, 150);"></label>
          </div>

					<input type="submit" value="Play">
        </form>
      </div>
    </div>
  </div>

  <div class="modal" id="shop-modal" style="display: none">
    <div class="modal-dialog">
      <div class="modal-header">
        <h2>Shop</h2>
      </div>
			<div class="modal-body">
				<h2>TODO: add items for sale</h2>
			</div>
		</div>
  </div>

<script>
	// Get the modal
	const joinmodal = document.getElementById("join-modal");
	const form = joinmodal.querySelector('form');
	const submitButton = joinmodal.querySelector('input[type="submit"]');
	submitButton.disabled = true;

	// Add event listeners for the nickname input field and color radio buttons
	const nicknameInput = joinmodal.querySelector('input[name="nick"]');
	const colorRadios = joinmodal.querySelectorAll('input[name="color"]');
	nicknameInput.addEventListener('input', updateSubmitButtonState);
	colorRadios.forEach(radio => {
		radio.addEventListener('change', updateSubmitButtonState);
	});

	// Function to update the state of the submit button based on the input values
	function updateSubmitButtonState() {
		const nickname = nicknameInput.value.trim();
		const color = joinmodal.querySelector('input[name="color"]:checked');

		if (nickname.length >= 3 && color !== null && nickname.length <= 24) {
			submitButton.disabled = false;
		} else {
			submitButton.disabled = true;
		}
	}

	form.addEventListener('submit', function(event) {
		event.preventDefault();

		const nick = joinmodal.querySelector('input[name="nick"]').value;
		const color = joinmodal.querySelector('input[name="color"]:checked').value;

		joinmodal.style.display = "none";
		form.reset();
		runClient(nick, color);
	});

	async function runClient(player_nick, player_color){
		var bulletHitEmitterJSON = {
					lifetime: { //lifetime of particle
							min: 0.15,
							max: 0.25
					},
					frequency: 0.008,
					spawnChance: 1,
					particlesPerWave: 1,
					emitterLifetime: 0.2, //how long to emit for
					maxParticles: 1000,
					pos: {
							x: 0,
							y: 0
					},
					addAtBack: false,
					behaviors: [
							{
									type: 'alpha',
									config: {
											alpha: {
													list: [
															{
																	value: 1,
																	time: 0
															},
															{
																	value: 0,
																	time: 1
															}
													],
											},
									}
							},
							{
									type: 'scale',
									config: {
											scale: {
													list: [
															{
																	value: 1,
																	time: 0
															},
															{
																	value: 0,
																	time: 1
															}
													],
											},
									}
							},
							{
									type: 'color',
									config: {
											color: {
													list: [
															{
																	value: "ffff00",
																	time: 0
															},
															{
																	value: "ff8000",
																	time: 1
															}
													],
											},
									}
							},
							{
									type: 'moveSpeed',
									config: {
											speed: {
													list: [
															{
																	value: 600,
																	time: 0
															},
															{
																	value: 400,
																	time: 1
															}
													],
													isStepped: false
											},
									}
							},
					],
			};

			var explosionEmitterJSON = {
				lifetime: { 
					min: 0.2,
					max: 0.5
				},
				frequency: 0.03,
				spawnChance: 0.9,
				particlesPerWave: 30,
				emitterLifetime: 0.2,
				maxParticles: 1000,
				pos: {
					x: 0,
					y: 0
				},
				addAtBack: false,
				radius: { // This describes how the particles will spread out
					min: 0,
					max: 360
				},
				speed: { // This describes the speed of the particles
					min: 300,
					max: 600
				},
				behaviors: [
					{
						type: 'alpha',
						config: {
							alpha: {
								list: [
									{
										value: 1,
										time: 0
									},
									{
										value: 0,
										time: 1
									}
								],
							},
						}
					},
					{
						type: 'scale',
						config: {
							scale: {
								list: [
									{
										value: 1,
										time: 0
									},
									{
										value: 0,
										time: 1
									}
								],
							},
						}
					},
					{
						type: 'color',
						config: {
							color: {
								list: [
									{
										value: "ff0000",
										time: 0
									},
									{
										value: "ffff00",
										time: 0.5
									},
									{
										value: "ffffff",
										time: 1
									}
								],
							},
						}
					},
					{
							type: 'rotationStatic',
							config: {
									min: 0,
									max: 360
							}
					},
					{
						type: 'moveSpeed',
						config: {
							speed: {
								list: [
									{
										value: 600,
										time: 0
									},
									{
										value: 100,
										time: 1
									}
								],
								isStepped: false
							},
						}
					},
				],
			};

		var gameState = {};
		var worldLoot = {};
		var emissions = [];
		var socket = null;
		var opened = false;
		var public_id = null;
		var keymap = {
			"ArrowUp": false,
			"ArrowDown": false,
			"ArrowLeft": false,
			"ArrowRight": false,
			"A": false,
			"D": false,
			" ": false,
		};

		const invr2 = 0.7071067811865475;
		const PI = 3.14159265358979323;

		const bullet_distance = 500;
		const player_speed = 200;
		const player_radius = 25;
		const fadeRate = 8;
		const rotation_speed = PI;

		const healthbar_maxwidth = 0.15; //This gets multiplied by the  screen width

		const app = new PIXI.Application({
				width: window.innerWidth,
				height: window.innerHeight,
				backgroundColor: 0x101510
		});

		let gunshot_texture, pistol_ammo_texture, coins_texture, coins_label_texture, heart_texture, seamless_texture, speed_boost_texture;
		await Promise.all([
			PIXI.Assets.load("static/textures/gunshot.png").then(texture => gunshot_texture = texture),
			PIXI.Assets.load("static/textures/pistol_ammo.png").then(texture => pistol_ammo_texture = texture),
			PIXI.Assets.load("static/textures/coins.png").then(texture => coins_texture = texture),
			PIXI.Assets.load("static/textures/coins_label.png").then(texture => coins_label_texture = texture),
			PIXI.Assets.load("static/textures/heart.png").then(texture => heart_texture = texture),
			PIXI.Assets.load("static/textures/seamless.jpg").then(texture => seamless_texture = texture),
			PIXI.Assets.load("static/textures/speed_boost.png").then(texture => speed_boost_texture = texture)
		]);

		var background = new PIXI.TilingSprite(
			seamless_texture,
			(3+Math.ceil(app.screen.width / seamless_texture.width))*seamless_texture.width,
			(3+Math.ceil(app.screen.height / seamless_texture.height))*seamless_texture.height
		);

		const world = new PIXI.Container();
		world.position.set(app.screen.width/2, app.screen.height/2);

		//tells pixijs to consider the zindex of the children
		world.sortableChildren = true;

		const players_container = new PIXI.Container();
		const loot_container = new PIXI.Container();
		const bullets_container = new PIXI.Container();

		//higher zindex makes it appear on top
		bullets_container.zIndex = 1;
		players_container.zIndex = 2;
		loot_container.zIndex = 3;

		world.addChild(players_container);
		world.addChild(loot_container);
		world.addChild(bullets_container);
		world.addChild(background);

		app.stage.addChild(world);

		//Add the healthbar
		var healthbar = new PIXI.Sprite(PIXI.Texture.WHITE);
		healthbar.width = app.screen.width * healthbar_maxwidth;
		healthbar.height = 20;
		healthbar.tint = 0x00ff00;
		healthbar.position.set(app.screen.width*0.02, app.screen.height*0.98 - 20);
		app.stage.addChild(healthbar);

		//Add the hearth next to the healthbar TODO reduce the hard coded values and make a container for the healthbar and the heart
		var heart_sprite = new PIXI.Sprite(heart_texture);
		heart_sprite.scale.set(0.7,0.7);
		heart_sprite.position.set(
			app.screen.width * (healthbar_maxwidth+0.03),
			app.screen.height*0.98 - 10 - heart_sprite.height/2
		);
		app.stage.addChild(heart_sprite);

		//add the coords text
		var coords_text = new PIXI.Text("x: -, y: -", { fontFamily: "Arial", fontSize: 18, fill: 0x88ff88 });
		coords_text.anchor.set(0.5);
		coords_text.position.set(app.screen.width * 0.9, app.screen.height*0.02 + 20);
		app.stage.addChild(coords_text);

		//add the cash text
		var cash_text = new PIXI.Text("?", {
			fill: "#e5a50a",
			fillGradientType: 1,
			fontFamily: "Helvetica",
			fontSize: 32,
			fontWeight: "bold",
			letterSpacing: 1,
			lineJoin: "round",
			stroke: "#99c1f1"
		});
		cash_text.anchor.set(0.5);
		cash_text.position.set(app.screen.width * 0.02, app.screen.height*0.02 + 20);
		app.stage.addChild(cash_text);

		var coin_sprite = new PIXI.Sprite(coins_label_texture);
		coin_sprite.position.set(
			app.screen.width * 0.05,
			app.screen.height * 0.02
		);
		app.stage.addChild(coin_sprite);

		//Add the text that shows ammo left
		var ammo_text = new PIXI.Text("?", { fontFamily: "\"Lucida Console\", Monaco, monospace", fontSize: 23, fill: 0xffee00 });
		ammo_text.anchor.set(0.5);
		ammo_text.position.set(app.screen.width * 0.9, app.screen.height*0.98 - 15);
		app.stage.addChild(ammo_text);

		var pistol_ammo_sprite = new PIXI.Sprite(pistol_ammo_texture);
		//heart_sprite.scale.set(0.7,0.7);
		pistol_ammo_sprite.position.set(
			app.screen.width * 0.93,
			app.screen.height*0.98 - 35
		);
		app.stage.addChild(pistol_ammo_sprite);

		//false if not hit, distance to hit point otherwise
		//TODO wasm
		function line_circle_intersect(xp, yp, xc, yc, rot){
			//shift everything to make line start from origin
			let a = xc - xp;
			let b = yc - yp;
			let rot_90 = rot - PI/2;

			//compute the quadratic's 'b' coefficient (for variable r in polar form)
			let qb = -(2*a*Math.cos(rot_90) + 2*b*Math.sin(rot_90));
			let discriminant = qb*qb - 4*(a*a + b*b - player_radius*player_radius);
			if (discriminant < 0){ //no real roots (no line-circle intersection)
				return false;
			}

			let root = Math.sqrt(discriminant);

			//the actual solutions
			const r1 = (root - qb)/2;
			const r2 = (-root - qb)/2;

			const r1Good = bullet_distance > r1 && r1 > 0;
			const r2Good = bullet_distance > r2 && r2 > 0;

			if (!r1Good && !r2Good)
				return false;
			else if (r1Good != r2Good){
				if (r1Good)
					return r1;
				else
					return r2;
			} else if (r1Good && r2Good){
				return Math.min(r1, r2);
			}
		}

		const openWebSocket = function(){
			//fetch(`https://${window.location.hostname}/register`, {
			fetch(`http://${window.location.hostname}/register`, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(
					{
						nick: player_nick,
						color: player_color
					}
				)
			})
			.then(response => response.json())
			.then(result => {
				public_id = result['public'];
				//socket = new WebSocket(`wss://${window.location.hostname}/ws/`+result['private']);
				socket = new WebSocket(`ws://${window.location.hostname}/ws/`+result['private']);
				socket.onmessage = recvFn;
				socket.onopen = () => {
					opened=true;
					socket.send(JSON.stringify({"t":"StateQuery"}));
				};
				socket.onclose = (event)=>{
					opened=false;
				}
			});
		};

		const getPlayerSprite = function(player){
			var player_container = new PIXI.Container();
			player_container.position.set(player.x, player.y);
			player_container.rotation = player.rotation;
			var square = new PIXI.Sprite(PIXI.Texture.WHITE);
			square.anchor.set(0.5);
			square.width = 50;
			square.height = 50;
			square.anchor.set(0.5);
			square.tint = player.color.r << 16 | player.color.g << 8 | player.color.b;

			var text = new PIXI.Text(player.name, { fontFamily: "Arial", fontSize: 16, fill: 0xffffff });
			text.anchor.set(0.5);
			text.position.set(0, -40);
			player_container.addChild(square);
			player_container.addChild(text);
			return player_container;
		}

		const getLootSprite = function(lootObj){
			var loot_obj = new PIXI.Container();
			loot_obj.position.set(lootObj.x, lootObj.y);
			var loot_texture = new PIXI.Sprite({
				"Cash": coins_texture,
				"PistolAmmo": pistol_ammo_texture,
				"SpeedBoost": speed_boost_texture
			}[typeof lootObj.loot === "string" ? lootObj.loot:Object.keys(lootObj.loot)[0]]);
			console.log(Object.keys(lootObj.loot)[0]);
			loot_texture.anchor.set(0.5);
			loot_obj.addChild(loot_texture);
			return loot_obj;
		}

		const update_healthbar = function(healthvalue){
			const prcnt = healthvalue / 100;
			healthbar.width = Math.max(0, app.screen.width * healthbar_maxwidth * prcnt);
			healthbar.tint = Math.round(0xff * prcnt) << 8 | Math.round((1-prcnt) * 0xff) << 16;
		}

		const handle_gamestate = function(state){
			//remove all other sprites
			for (var i = world.children.length - 1; i >= 0; i--)
				players_container.removeChild(world.children[i]);

			//TODO also remove loot

			gameState = {};
			worldLoot = {};
			state.players.forEach((p) => {
				const square = getPlayerSprite(p);
				if (p.public_id == public_id){
					square.x = app.screen.width/2;
					square.y = app.screen.height/2;
					world.pivot.x = p.x;
					world.pivot.y = p.y;
					app.stage.addChild(square);
					ammo_text.text = p.inventory.weapons[0].ammo;
					cash_text.text = p.cash;
				} else {
					players_container.addChild(square);
				}

				gameState[p.public_id] = {
					graphics: square,
					p: p
				};
			});	

			Object.entries(state.loot).forEach(([loot_uuid, lootObj]) => {
				summon_loot(loot_uuid, lootObj);
			});
		};

		const summon_loot = function(loot_uuid, lootObj){
			const loot_sprite = getLootSprite(lootObj);
			loot_container.addChild(loot_sprite);
			worldLoot[loot_uuid] = {
				graphics: loot_sprite,
				l: lootObj,
			};
		}

		const handle_motionupdate = function(content){
			let broadcaster = content["from"];
			gameState[broadcaster].p.motion.direction = content.direction;
			if (broadcaster == public_id){
				world.pivot.x = content.x;
				world.pivot.y = content.y;
			} else {
				gameState[broadcaster].graphics.x = content.x;
				gameState[broadcaster].graphics.y = content.y;
			}
		}

		const handle_rotationupdate = function(content){
			let broadcaster = content["from"];
			gameState[broadcaster].p.rotation_motion.direction = content.direction;
			gameState[broadcaster].graphics.rotation = content.r;
		}

		const handle_trigUpdate = function(content){
			const weapon = content.weptype;
			const updater = content.by;
			const isTriggered = content.pressed;
			if (!isTriggered) //temporary
				return;
			if (weapon == "Pistol"){
				const line_start_x = public_id == updater ? world.pivot.x:gameState[updater].graphics.x;
				const line_start_y = public_id == updater ? world.pivot.y:gameState[updater].graphics.y;

				const line_rotation = gameState[updater].graphics.rotation;
				let hitInfo = {
					hit: false,
					shortest_line: bullet_distance,
					x: 0,
					y: 0
				};
				Object.entries(gameState).forEach(([pubid, item]) => {
					if (pubid == updater) //don't check if the shooter is shooting themselves
						return;

					const check_x = pubid == public_id ? world.pivot.x:item.graphics.x;
					const check_y = pubid == public_id ? world.pivot.y:item.graphics.y;

					const hit = line_circle_intersect(line_start_x, line_start_y, check_x, check_y, line_rotation);
					if (hit === false)
						return;

					hitInfo.hit = true;
					if (hit >= hitInfo.shortest_line)
						return;

					hitInfo.shortest_line = hit;
					hitInfo.x = check_x;
					hitInfo.y = check_y;
				});

				//draws a line instead of gunshot
				//const bullet_line = new PIXI.Graphics();
				//bullet_line.lineStyle(4, 0xffff00, 1);
				//bullet_line.position.set(line_start_x, line_start_y);
				//bullet_line.lineTo(0, -hitInfo.shortest_line);
				//bullet_line.rotation = line_rotation;
				//bullets_container.addChild(bullet_line);

				const gunshot_sprite = new PIXI.Sprite(gunshot_texture);
				gunshot_sprite.position.set(line_start_x, line_start_y);
				gunshot_sprite.rotation = line_rotation;
				gunshot_sprite.anchor.set(0.5, 1.2); //this affects the gunshot position relative to the shooter
				gunshot_sprite.scale.set(0.25, 0.25); //This depends on the png size
				bullets_container.addChild(gunshot_sprite);

				if (hitInfo.hit){
					let emitJSON = JSON.parse(JSON.stringify(bulletHitEmitterJSON)); //careful here
					emitJSON.pos = {
						x: hitInfo.x,
						y: hitInfo.y
					};
					emitJSON.behaviors.push(
						{
								type: 'rotationStatic',
								config: {
										min: (180/PI)*line_rotation+90 - 30,
										max: (180/PI)*line_rotation+90 + 30
								}
						}
					);
					emitJSON.behaviors.push(
						{
							type: 'textureSingle',
							config: {
									texture: PIXI.Texture.WHITE
								}
						}
					);

					let emitter = new PIXI.particles.Emitter(
						world,
						emitJSON
					);
					emitter.emit = true;
					emissions.push(emitter);
				}
			}
		}

		const handle_playerjoin = function(content){
			if (content.public_id == public_id){ //this happens when spawning
				world.pivot.x = content.x;
				world.pivot.y = content.y;
				gameState[public_id].p = content;
				gameState[public_id].graphics.rotation = content.rotation;
				
				//update coords text
				coords_text.text = `x: ${Math.round(world.pivot.x)}, y: ${-Math.round(world.pivot.y)}`;

				//update health bar
				update_healthbar(content.health);

				//update ammo bar
				const inventory = content.inventory;
				const selectedWeapon = inventory.weapons[inventory.selection];
				ammo_text.text = selectedWeapon.ammo;

				//update cash bar
				cash_text.text = content.cash;
			} else {
				const square = getPlayerSprite(content);
				players_container.addChild(square);
				gameState[content.public_id] = {
					graphics: square,
					p: content
				};
			}
		}

		const handle_healthUpdate = function(newHealth){
			gameState[public_id].p.health = newHealth;
			update_healthbar(newHealth);
		}

		const handle_playerleave = function(public_id){
			players_container.removeChild(gameState[public_id].graphics);
			delete gameState[public_id];
		}

		const handle_playerdeath = function(content){
			const is_self = content.from == public_id;
			if (is_self){
				summon_loot(content.loot_uuid, content.loot);
				alert("You died!");
				socket.send(
					JSON.stringify({
						"t":"Spawn"
					})
				);
				console.log(worldLoot);
			} else {
				const emitJSON = JSON.parse(JSON.stringify(explosionEmitterJSON));
				emitJSON.pos = {
					x: gameState[content.from].p.x,
					y: gameState[content.from].p.y
				};
				emitJSON.behaviors.push({
					type: 'textureSingle',
					config: {
						texture: PIXI.Texture.WHITE
					}
				});
				let emitter = new PIXI.particles.Emitter(
					world,
					emitJSON
				);
				emitter.emit = true;
				emissions.push(emitter);
				summon_loot(content.loot_uuid, content.loot);
				handle_playerleave(content.from);
			}
		}

		const handle_rejection = function(content){
			console.log(`rejection: ${content}`);
			delete worldLoot[content].claimed;
		}

		const handle_lootcollection = function(content){
			console.log(content);
			if (!(content.loot_id in worldLoot)){
				console.log("Could not find collected loot");
				return;
			}
			loot_container.removeChild(worldLoot[content.loot_id].graphics);
			const loot_content_clone = JSON.parse(JSON.stringify(worldLoot[content.loot_id].l.loot));
			delete worldLoot[content.loot_id];

			const loot_type = typeof loot_content_clone === 'string' ? loot_content_clone:Object.keys(loot_content_clone)[0];
			const loot_value = typeof loot_content_clone === 'string' ? null:Object.values(loot_content_clone)[0];
			if (content.collector !== public_id && loot_type !== "SpeedBoost") return;

			console.log(`action on ${loot_type}`);

			({
				"Cash": () => {
					gameState[content.collector].p.cash += loot_value;
					cash_text.text = gameState[content.collector].p.cash;
				},
				"PistolAmmo": () => {
					const pp = gameState[content.collector].p;
					pp.inventory.weapons[pp.inventory.selection].ammo += loot_value;
					ammo_text.text = pp.inventory.weapons[pp.inventory.selection].ammo;
				},
				"SpeedBoost": () => {
					gameState[content.collector].p.speed += 1.0;
					console.log(`Collected speedboost: ${gameState[content.collector].p.speed}`);
				}
			}[loot_type])();
		}

		const recvFn = function(event) {
			let data = JSON.parse(event.data);
			console.log(data);
			let datatype = data["t"];
			let content = data["c"];
			const fmap = {
				"GameState": handle_gamestate,
				"MotionUpdate": handle_motionupdate,
				"RotationUpdate": handle_rotationupdate,
				"PlayerJoin": handle_playerjoin,
				"PlayerLeave": handle_playerleave,
				"PlayerDeath": handle_playerdeath,
				"LootCollected": handle_lootcollection,
				"TrigUpdate": handle_trigUpdate,
				"HealthUpdate": handle_healthUpdate,
				"LootReject": handle_rejection
			};
			if (!(datatype in fmap)){
				console.error(`received unknown server message: ${JSON.stringify(content)}`);
				return;
			}
			fmap[datatype](content);
		};

		const keyAction = function (repeated, name, up){
			if (!opened || repeated) return;

			let rotation_keys = ["arrowleft","arrowright"];
			let translation_keys = ["w", "a", "s", "d"]; //case sensitive (todo make this insensitive)
			let misc_keys = [" ", "escape"];
			
			name = name.toLowerCase();
			keymap[name] = !up;

			if (translation_keys.includes(name)){
				let response = "";
				if (keymap["w"] && keymap["d"]){
					response = "MoveUpRight";
				} else if (keymap["w"] && keymap["a"]){
					response = "MoveUpLeft";
				} else if (keymap["w"]){
					response = "MoveUp";
				}else if (keymap["s"] && keymap["d"]){
					response = "MoveDownRight";
				} else if (keymap["s"] && keymap["a"]){
					response = "MoveDownLeft";
				} else if (keymap["s"]){
					response = "MoveDown";
				} else if (keymap["a"]){
					response = "MoveLeft";
				} else if (keymap["d"]){
					response = "MoveRight";
				} else {
					response = "Stopped";
				}
				//console.log("sending " + response);
				socket.send(
					JSON.stringify({
						"t":"MotionUpdate",
						"c":{
							"motion": response,
						 }
					})
				);
			} else if (rotation_keys.includes(name)) {
				let response = "";
				if (keymap["arrowleft"]){
					response = "AntiClockwise";
				} else if (keymap["arrowright"]){
					response = "Clockwise";
				} else {
					response = "Stopped";
				}
				//console.log("sending " + response);
				socket.send(
					JSON.stringify({
						"t":"RotationUpdate",
						"c":{
							"direction": response,
						 }
					})
				);
			} else if (misc_keys.includes(name)) {
				if (name == " "){ //shoot
					const inventory = gameState[public_id].p.inventory;
					const selectedWeapon = inventory.weapons[inventory.selection];
					if (selectedWeapon.ammo <= 0)
						return;
					if (keymap[name])
						ammo_text.text = --selectedWeapon.ammo;
					socket.send(
						JSON.stringify({
							"t":"TrigUpdate",
							"c":{
								"pressed": keymap[name],
							 }
						})
					);
				} else if (name == "escape") {
					document.getElementById("shop-modal").style.display = keymap[name] ? "flex":"none";
				}
			}
		};

		document.body.appendChild(app.view);
		openWebSocket();

		const ticker = PIXI.Ticker.shared.add(delta => {
			const deltaTime = delta / (1000*PIXI.settings.TARGET_FPMS);
			Object.values(gameState).forEach(player => {
				//apply rotations
				switch (player.p.rotation_motion.direction){
					case "Clockwise":
						player.graphics.rotation += rotation_speed * deltaTime;break;
					case "AntiClockwise":
						player.graphics.rotation += -rotation_speed * deltaTime;break;
				}
				
				const shallow_copy = player.p.public_id == public_id ? world.pivot:player.graphics
				const move_speed = player_speed * player.p.speed;
				switch (player.p.motion.direction){
					case "MoveUp":
						shallow_copy.y -= move_speed * deltaTime;break;
					case "MoveDown":
						shallow_copy.y += move_speed * deltaTime;break;
					case "MoveLeft":
						shallow_copy.x -= move_speed * deltaTime;break;
					case "MoveRight":
						shallow_copy.x += move_speed * deltaTime;break;
					case "MoveUpRight":
						shallow_copy.x += move_speed * deltaTime * invr2;
						shallow_copy.y -= move_speed * deltaTime * invr2;
						break;
					case "MoveDownRight":
						shallow_copy.x += move_speed * deltaTime * invr2;
						shallow_copy.y += move_speed * deltaTime * invr2;
						break;
					case "MoveDownLeft":
						shallow_copy.x -= move_speed * deltaTime * invr2;
						shallow_copy.y += move_speed * deltaTime * invr2;
						break;
					case "MoveUpLeft":
						shallow_copy.x -= move_speed * deltaTime * invr2;
						shallow_copy.y -= move_speed * deltaTime * invr2;
						break;
				}
				if (player.p.public_id == public_id){
					const tile_x = Math.floor(world.pivot.x / seamless_texture.width);
					const tile_y = Math.floor(world.pivot.y / seamless_texture.height);
					background.x = tile_x*seamless_texture.width - background.width/2;
					background.y = tile_y*seamless_texture.height - background.height/2;

					coords_text.text = `x: ${Math.round(world.pivot.x)}, y: ${-Math.round(world.pivot.y)}`;
				}
			});

			for (let i = 0; i < bullets_container.children.length; ++i){
				bullets_container.children[i].scale.x = Math.max(
					0,
					bullets_container.children[i].scale.x-fadeRate*deltaTime
				);
			}
			//remove the gunshots from memory
			bullets_container.children = bullets_container.children.filter(child => child.scale.x > 0.01);

			emissions.forEach(emitter => {
				if (!emitter.emit)
					emitter.destroy();
			});
			emissions = emissions.filter(emitter => emitter.emit);
			emissions.forEach(emitter => emitter.update(deltaTime));

			//TODO it happens often that server rejects claim
			Object.entries(worldLoot).forEach(([loot_id, lootObj]) => {
				if (lootObj.claimed)
					return;
				const trig = Math.pow(lootObj.l.x - world.pivot.x, 2) + Math.pow(lootObj.l.y - world.pivot.y, 2) < 10*10;
				if (!trig)
					return;
				lootObj.claimed = true;
				socket.send(JSON.stringify({"t":"ClaimLoot","c":{"loot_id": loot_id}}));
				console.log(`sent claim for ${loot_id}`);
			});
		});

		ticker.speed = 1;
		ticker.minFPS = 30;
		ticker.maxFPS = 60;
		ticker.start();

		window.addEventListener("resize", function(){
			app.renderer.resize(window.innerWidth, window.innerHeight);
		});

		window.addEventListener('keydown', (event) => keyAction(event.repeat, event.key, false));
		window.addEventListener('keyup', (event) => keyAction(event.repeat, event.key, true));
	}
</script>
</body>
</html>
